<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js vr - dragging</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
  <canvas style="display:none" id="img-canvas"></canvas>
  <div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - dragging
  </div>

  <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>

  <script type="module">

    const imageCanvas = document.getElementById("img-canvas")
    const imageCanvasCtx = imageCanvas.getContext("2d")


    import * as THREE from './three.js/build/three.module.js';
    import { OrbitControls } from './three.js/examples/jsm/controls/OrbitControls.js';
    import { VRButton } from './VRAuto.js';
    import { XRControllerModelFactory } from './three.js/examples/jsm/webxr/XRControllerModelFactory.js';

    import { Resnetvis } from "./resnetvis.mjs"

    let visualization;

    let container;
    let camera, scene, renderer;
    let controllerLeft, controllerRight;
    let controllerGripLeft, controllerGripRight;

    let grabposLeft, grabposRight;

    let raycaster;

    const intersected = [];
    const tempMatrix = new THREE.Matrix4();

    let controls, world, group;

    let rotpoint;


    const config = { moveScale: true }
    let prevButtons = { left: {}, right: {} }


    ///////////////////////////////////////////////////////////////////////////////
    // funcs
    function jpegToTensor(url, callback) {

      const loader = new THREE.ImageLoader();

      // load a image resource
      loader.load(
        // resource URL
        url,
        (image) => {
          imageCanvas.width = image.width
          imageCanvas.height = image.height
          imageCanvasCtx.drawImage(image, 0, 0)
          const imageData = imageCanvasCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height)
          console.log(imageData.data)
          // const floats = new Float32Array(imageData.data)
          const unclamped = new Uint8Array(imageData.data)
          const tensor = new onnx.Tensor(unclamped, 'uint8', [1, 4, imageData.width, imageData.height])
          callback(tensor)
        })
    }
    jpegToTensor('./imagenet/n01440764_tench.JPEG', (tensor) => {
      console.log(tensor)
    })


    function tensorImagePlane(tensor) {
      if (tensor.dims.length !== 4) {
        throw new Error(`image tensor needs 4 dims`)
      }
      const hasA = tensor.dims[1] === 4
      const texture = new THREE.DataTexture(tensor.data, tensor.dims[2], tensor.dims[3], hasA ? THREE.RGBAFormat : THREE.RGBFormat);
      const plane = doubleSidedPlane(texture)
      return plane
    }
    const sdftime = performance.now()
    jpegToTensor("./imagenet/n01514859_hen.JPEG", (tensor) => {
      console.log(tensor.data)
      console.log("HAVETENSOR")
      const object = tensorImagePlane(tensor)
      world.add(object)
      object.position.add(new THREE.Vector3(0, 0, 0))
      console.log(`load took ${performance.now() - sdftime}`)

    })

    function doubleSidedPlane(texture) {
      const material = new THREE.MeshBasicMaterial({
        map: texture
      });

      // make one visible from front and one from back
      const object = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material)
      const object2 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material)
      const group = new THREE.Group()
      group.add(object)
      group.add(object2)
      object2.rotateY(Math.PI)
      return group
    }

    function imagePlane(url, callback) {
      const loader = new THREE.TextureLoader();

      // load a resource
      loader.load(
        // resource URL
        url,

        // onLoad callback
        function (texture) {
          console.log("texture")
          console.log(texture)
          callback(doubleSidedPlane(texture))
        },

        // onProgress callback currently not supported
        undefined,

        // onError callback
        function (err) {
          console.error('An error happened.');
        }
      );
    }
    imagePlane("./imagenet/n09468604_valley.JPEG", (object) => {
      world.add(object)
      object.position.add(new THREE.Vector3(1, 1, 1))
    })

    ///////////////////////////////////////////////////////////////////////////////


    init();
    visualization = new Resnetvis(world);
    animate();

    window.addEventListener('vrdisplayactivate', function () {
      console.log("vrdisplayactivate")
    });

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      world = new THREE.Group();
      scene.add(world);
      scene.background = new THREE.Color(0x808080);

      // this is flatscreen camera - xr makes camera with different settings
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.6, 3);

      controls = new OrbitControls(camera, container);
      controls.target.set(0, 1.6, 0);
      controls.update();

      const floorGeometry = new THREE.PlaneGeometry(4, 4);
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        roughness: 1.0,
        metalness: 0.0
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = - Math.PI / 2;
      floor.receiveShadow = true;
      world.add(floor);

      world.add(new THREE.HemisphereLight(0x808080, 0x606060));

      const light = new THREE.DirectionalLight(0xffffff);
      light.position.set(0, 6, 0);
      light.castShadow = true;
      light.shadow.camera.top = 2;
      light.shadow.camera.bottom = - 2;
      light.shadow.camera.right = 2;
      light.shadow.camera.left = - 2;
      light.shadow.mapSize.set(4096, 4096);
      world.add(light);

      group = new THREE.Group();
      world.add(group);

      // rotpoint = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshStandardMaterial({
      //   color: 0xffffff,
      //   roughness: 0.7,
      //   metalness: 0.0
      // }));
      // scene.add(rotpoint)

      const geometries = [
        new THREE.BoxGeometry(0.2, 0.2, 0.2),
        new THREE.ConeGeometry(0.2, 0.2, 64),
        new THREE.CylinderGeometry(0.2, 0.2, 0.2, 64),
        new THREE.IcosahedronGeometry(0.2, 4),
        new THREE.TorusGeometry(0.2, 0.04, 64, 32)
      ];

      for (let i = 0; i < 50; i++) {

        const geometry = geometries[Math.floor(Math.random() * geometries.length)];
        const material = new THREE.MeshStandardMaterial({
          color: Math.random() * 0xffffff,
          roughness: 0.7,
          metalness: 0.0
        });

        const object = new THREE.Mesh(geometry, material);

        object.position.x = Math.random() * 4 - 2;
        object.position.y = Math.random() * 2;
        object.position.z = Math.random() * 4 - 2;

        object.rotation.x = Math.random() * 2 * Math.PI;
        object.rotation.y = Math.random() * 2 * Math.PI;
        object.rotation.z = Math.random() * 2 * Math.PI;

        object.scale.setScalar(Math.random() + 0.5);

        object.castShadow = true;
        object.receiveShadow = true;

        group.add(object);

      }

      //

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      document.body.appendChild(VRButton.createButton(renderer));

      // controllers
      const contone = renderer.xr.getController(0);
      const conttwo = renderer.xr.getController(1);
      const gripone = renderer.xr.getControllerGrip(0);
      const griptwo = renderer.xr.getControllerGrip(1);
      // @TODO: make sure controller 0 is actually left
      console.log(contone)
      controllerLeft = contone
      controllerLeft.addEventListener('selectstart', onSelectStart);
      controllerLeft.addEventListener('selectend', onSelectEnd);
      scene.add(controllerLeft);

      controllerRight = conttwo
      controllerRight.addEventListener('selectstart', onSelectStart);
      controllerRight.addEventListener('selectend', onSelectEnd);
      scene.add(controllerRight);

      const controllerModelFactory = new XRControllerModelFactory();

      controllerGripLeft = gripone
      controllerGripLeft.add(controllerModelFactory.createControllerModel(controllerGripLeft));
      scene.add(controllerGripLeft);

      controllerGripRight = griptwo
      controllerGripRight.add(controllerModelFactory.createControllerModel(controllerGripRight));
      scene.add(controllerGripRight);

      //

      const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 1)]);

      const line = new THREE.Line(geometry);
      line.name = 'line';
      line.scale.z = 5;

      controllerLeft.add(line.clone());
      controllerRight.add(line.clone());

      raycaster = new THREE.Raycaster();

      //
      window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function onSelectStart(event) {

      const controller = event.target;

      const intersections = getIntersections(controller);

      if (intersections.length > 0) {

        const intersection = intersections[0];
        const object = intersection.object;
        object.material.emissive.b = 1;
        controller.attach(object);

        controller.userData.selected = object;

      }

    }

    function onSelectEnd(event) {

      const controller = event.target;

      if (controller.userData.selected !== undefined) {

        const object = controller.userData.selected;
        object.material.emissive.b = 0;
        group.attach(object);

        controller.userData.selected = undefined;

      }


    }

    function getIntersections(controller) {

      tempMatrix.identity().extractRotation(controller.matrixWorld);

      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

      return raycaster.intersectObjects(group.children);

    }

    function intersectObjects(controller) {

      // Do not highlight when already selected

      if (controller.userData.selected !== undefined) return;

      const line = controller.getObjectByName('line');
      const intersections = getIntersections(controller);

      if (intersections.length > 0) {

        const intersection = intersections[0];

        const object = intersection.object;
        object.material.emissive.r = 1;
        intersected.push(object);

        line.scale.z = intersection.distance;

      } else {

        line.scale.z = 5;

      }

    }

    function cleanIntersected() {

      while (intersected.length) {

        const object = intersected.pop();
        object.material.emissive.r = 0;

      }

    }

    //

    function animate() {

      renderer.setAnimationLoop(render);

    }

    function render() {
      const session = renderer.xr.getSession();
      let buttons = { left: [], right: [] }
      let axes = { left: [], right: [] }
      if (session && session.inputSources) {  //only if we are in a webXR session
        for (const sourceXR of session.inputSources) {
          buttons[sourceXR.handedness] = sourceXR.gamepad.buttons
          axes[sourceXR.handedness] = sourceXR.gamepad.axes
        }
      }

      // rotpoint.position.sub(rotpoint.position).add(world.position)

      // gorn+tiltbrush movement
      if (buttons.right[4]?.pressed && buttons.left[4]?.pressed) {
        const prevDir = grabposLeft.clone().sub(grabposRight)
        const newDir = controllerLeft.position.clone().sub(controllerRight.position)

        const angle = new THREE.Quaternion();
        angle.setFromUnitVectors(prevDir.clone().setY(0).normalize(), newDir.clone().setY(0).normalize())

        if (config.moveScale) {

          const scalar = newDir.length() / prevDir.length()
          const mat = new THREE.Matrix4()
          mat.makeScale(scalar, scalar, scalar)
          const offset = controllerRight.position.clone().sub(world.position)

          // scale AROUND SCENE ORIGIN and correct to around controller
          world.applyMatrix4(mat)
          world.position.sub(controllerRight.position.clone().multiplyScalar(scalar - 1))

          // translate, rotate, translate
          world.position.add(offset)
          world.applyQuaternion(angle)
          world.position.sub(offset.applyQuaternion(angle))

          // move
          world.position.add(controllerRight.position).sub(grabposRight)
        } else {

          const prevMidpoint = prevDir.clone().multiplyScalar(0.5).add(grabposRight)
          const midpoint = newDir.clone().multiplyScalar(0.5).add(controllerRight.position)

          // rotate world around controller midpoint
          const oldPosition = world.position.clone()
          const offset = midpoint.clone().sub(oldPosition)
          world.position.add(offset)
          world.applyQuaternion(angle)
          world.position.sub(offset.applyQuaternion(angle))

          world.position.add(midpoint).sub(prevMidpoint)
        }
      } else if (buttons.right[4]?.pressed) {
        const delta = controllerRight.position.clone().sub(grabposRight)
        world.position.add(delta)
      } else if (buttons.left[4]?.pressed) {
        const delta = controllerLeft.position.clone().sub(grabposLeft)
        world.position.add(delta)
      }
      grabposLeft = controllerLeft.position.clone()
      grabposRight = controllerRight.position.clone()

      cleanIntersected();

      intersectObjects(controllerLeft);
      intersectObjects(controllerRight);

      const inputs = { controllerLeft, controllerRight, buttons, prevButtons }
      if (visualization) {
        visualization.update(inputs)
      }

      renderer.render(scene, camera);
      prevButtons = JSON.parse(JSON.stringify(buttons))
    }
  </script>
</body>

</html>